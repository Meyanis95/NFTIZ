"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packToStream = void 0;
const stream_1 = require("stream");
const it_last_1 = __importDefault(require("it-last"));
const it_pipe_1 = __importDefault(require("it-pipe"));
const car_1 = require("@ipld/car");
const ipfs_unixfs_importer_1 = require("ipfs-unixfs-importer");
// @ts-ignore
const index_js_1 = require("ipfs-core-utils/src/files/normalise-input/index.js");
const glob_source_js_1 = __importDefault(require("ipfs-utils/src/files/glob-source.js"));
const memory_1 = require("../blockstore/memory");
const constants_1 = require("./constants");
// Node version of toCar with Node Stream Writable
async function packToStream({ input, writable, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory }) {
    if (!input || (Array.isArray(input) && !input.length)) {
        throw new Error('given input could not be parsed correctly');
    }
    const blockstore = userBlockstore ? userBlockstore : new memory_1.MemoryBlockStore();
    // Consume the source
    const rootEntry = await (0, it_last_1.default)((0, it_pipe_1.default)((0, index_js_1.normaliseInput)((0, glob_source_js_1.default)(input, {
        recursive: true
    })), (source) => (0, ipfs_unixfs_importer_1.importer)(source, blockstore, {
        ...constants_1.unixfsImporterOptionsDefault,
        hasher: hasher || constants_1.unixfsImporterOptionsDefault.hasher,
        maxChunkSize: maxChunkSize || constants_1.unixfsImporterOptionsDefault.maxChunkSize,
        maxChildrenPerNode: maxChildrenPerNode || constants_1.unixfsImporterOptionsDefault.maxChildrenPerNode,
        wrapWithDirectory: wrapWithDirectory === false ? false : constants_1.unixfsImporterOptionsDefault.wrapWithDirectory
    })));
    if (!rootEntry || !rootEntry.cid) {
        throw new Error('given input could not be parsed correctly');
    }
    const root = rootEntry.cid;
    const { writer, out } = await car_1.CarWriter.create([root]);
    stream_1.Readable.from(out).pipe(writable);
    for await (const block of blockstore.blocks()) {
        await writer.put(block);
    }
    await writer.close();
    if (!userBlockstore) {
        await blockstore.close();
    }
    return { root };
}
exports.packToStream = packToStream;
